"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = void 0;
const ethers_1 = require("ethers");
const flatMap_1 = __importDefault(require("lodash/flatMap"));
const constants_1 = require("./constants");
const VERSION = '1';
// Certain types need to be encoded/transformed before ABI encoding happens
const VALUE_TRANSFORMATIONS = {
    string32: ethers_1.ethers.utils.formatBytes32String,
};
function buildSchemaHeader(types) {
    const allShortTypes = Object.keys(constants_1.PARAMETER_SHORT_TYPES);
    // Shorten all selected types with the corresponding "short" type
    // i.e. 'address' types get set as simply 'a' and 'bytes32' becomes
    // simply 'b' etc
    const selectedShortTypes = types.reduce((acc, type) => {
        const shortType = allShortTypes.find((st) => constants_1.PARAMETER_SHORT_TYPES[st] === type);
        return [...acc, shortType];
    }, []);
    return `${VERSION}${selectedShortTypes.join('')}`;
}
function buildNameValuePairs(parameters) {
    return (0, flatMap_1.default)(parameters, (parameter) => {
        const { name, value, type } = parameter;
        const transform = VALUE_TRANSFORMATIONS[type];
        const encodedName = ethers_1.ethers.utils.formatBytes32String(name);
        // If the type does not need to be transformed, return it as is
        if (!transform) {
            return [encodedName, value];
        }
        const encodedValue = transform(value);
        return [encodedName, encodedValue];
    });
}
function encode(parameters) {
    const types = parameters.map((parameter) => parameter.type);
    // Each parameter name is represented by a `bytes32` string. The value
    // types are what the user provides
    const nameTypePairs = (0, flatMap_1.default)(types, (type) => {
        const transformedType = constants_1.TYPE_TRANSFORMATIONS[type];
        return ['bytes32', transformedType !== null && transformedType !== void 0 ? transformedType : type];
    });
    // The first type is always a bytes32 as it represents the schema header
    const allTypes = ['bytes32', ...nameTypePairs];
    // Build the schema which includes the version and the abbreviated list of parameters
    const schemaHeader = buildSchemaHeader(types);
    const encodedHeader = ethers_1.ethers.utils.formatBytes32String(schemaHeader);
    // Map and encode each name/value pair where necessary
    const flatNameValues = buildNameValuePairs(parameters);
    // The schema header is always the first value to be encoded
    const allValues = [encodedHeader, ...flatNameValues];
    const encoder = new ethers_1.ethers.utils.AbiCoder();
    return encoder.encode(allTypes, allValues);
}
exports.encode = encode;
//# sourceMappingURL=encoding.js.map